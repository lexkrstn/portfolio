import express from 'express';
import React from 'react';
import { renderToString } from 'react-dom/server';
import { Provider } from 'react-redux';
import { MatchedRoute, matchRoutes, renderRoutes } from 'react-router-config';
import { StaticRouter } from 'react-router-dom';
import { Store } from 'redux';
import { ServerStyleSheet } from 'styled-components';
import { ReadyState } from '../browser/constants';
import '../browser/polyfills';
import { RootState } from '../browser/rootReducer';
import routes from '../browser/routes';
import storeFactory from '../browser/storeFactory';
import logger from './logger';

const router = express.Router();
export default router;

interface KeyValueObj {
  [key: string]: string;
}

type ReadyStateSelector = (state: RootState) => ReadyState;

function getWrappedComponent(component: any): any {
  return component.WrappedComponent ?
    getWrappedComponent(component.WrappedComponent) : component;
}

/**
 * Prefetches data of a component.
 *
 * @param {*} store Redux store
 * @param {*} search Query string.
 * @return Array of promises (may be empty).
 */
function fetchComponentData(
  batch: MatchedRoute<{}>,
  store: Store,
  search: string,
  cookies: KeyValueObj,
): Array<Promise<any>> {
  const requestTimeout = 10000; // wait 10 seconds for the data to arrive
  const component = getWrappedComponent(batch.route.component);
  if (!component.fillStoreOnSSR) {
    return [];
  }
  const readyStateSelectors: ReadyStateSelector[] = component.fillStoreOnSSR({
    cookies, params: batch.match.params, search, store,
  });
  return readyStateSelectors.map(readyStateSelector => {
    return new Promise((resolve, reject) => {
      const unsubscribe = store.subscribe(() => {
        const readyState = readyStateSelector(store.getState());
        if (readyState === ReadyState.Done || readyState === ReadyState.Fail) {
          clearTimeout(timeoutId);
          unsubscribe();
          if (readyState === ReadyState.Done) {
            resolve();
          } else {
            reject(new Error(`Failed to fetch SSR data for ${component.displayName}`));
          }
        }
      });
      const timeoutId = setTimeout(() => {
        unsubscribe();
        reject(new Error(`Failed to fetch SSR data for ${component.displayName} (timeout)`));
      }, requestTimeout);
    });
  });
}

router.get('*', async (req, res) => {
  const batches: Array<MatchedRoute<{}>> = matchRoutes(routes, req.path);
  if (!batches.length) {
    res.sendStatus(404);
    return;
  }
  const urlChunks = req.originalUrl.split('?');
  const queryString = urlChunks.length > 1 ? urlChunks[1] : '';

  const store = storeFactory();
  // const locale = req.language.replace('_', '-');
  // store.dispatch(i18nActions.setLocale(locale));

  const prefetchingPromises = batches.reduce((promises, batch: MatchedRoute<{}>) =>
    promises.concat(fetchComponentData(batch, store, queryString, req.cookies))
  , []);
  try {
    await Promise.all(prefetchingPromises);
  } catch (e) {
    logger.error(e);
    res.status(500).send('Internal server error');
  }
  const context: { url?: string } = {};
  let markup = '';
  const sheet = new ServerStyleSheet();
  try {
    const root = (
      <Provider store={store}>
        <StaticRouter
          location={req.url}
          context={context}
        >
          {renderRoutes(routes)}
        </StaticRouter>
      </Provider>
    );
    markup = renderToString(sheet.collectStyles(root));
  } catch (e) {
    logger.error('renderToString() failed', e);
  }
  /**
   * When the <Redirect> component renders on the server, it will call
   * the history object's replace method. The replacemethod sets
   * context.url to be the URL generated by the location that was
   * redirected to.
   */
  if (context.url) {
    res.redirect(302, context.url);
  } else {
    const initialState = store.getState();
    const vars = {
      initialState,
      markup,
      styleTags: sheet.getStyleTags(),
      title: 'Portfolio',
    };
    res.render('index', vars, (err, html) => {
      if (err) {
        return res.status(500).send(err);
      }
      // html = appendUniversalPortals(html);
      res.send(html);
    });
  }
});
