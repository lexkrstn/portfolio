import createCache from '@emotion/cache';
import { CacheProvider } from '@emotion/react';
import createEmotionServer from '@emotion/server/create-instance';
import express from 'express';
import { pick } from 'lodash';
import React from 'react';
import { renderToString } from 'react-dom/server';
import { Provider } from 'react-redux';
import { MatchedRoute, matchRoutes, renderRoutes } from 'react-router-config';
import { StaticRouter } from 'react-router-dom';
import { Store } from 'redux';
import '../../browser/src/polyfills';
import { RootState } from '../../browser/src/rootReducer';
import routes from '../../browser/src/routes';
import storeFactory from '../../browser/src/storeFactory';
import config from './config';
import logger from './logger';

const router = express.Router();
export default router;

interface KeyValueObj {
  [key: string]: string;
}

type ReadyStateSelector = (state: RootState) => boolean;

function getWrappedComponent(component: any): any {
  return component.WrappedComponent ?
    getWrappedComponent(component.WrappedComponent) : component;
}

/**
 * Prefetches data of a component.
 *
 * @param {*} store Redux store
 * @param {*} search Query string.
 * @return Array of promises (may be empty).
 */
function fetchComponentData(
  batch: MatchedRoute<{}>,
  store: Store,
  search: string,
  cookies: KeyValueObj,
): Array<Promise<any>> {
  const requestTimeout = 10000; // wait 10 seconds for the data to arrive
  const component = getWrappedComponent(batch.route.component);
  if (!component.fillStoreOnSSR) {
    return [];
  }
  const readyStateSelectors: ReadyStateSelector[] = component.fillStoreOnSSR({
    cookies, params: batch.match.params, search, store,
  });
  return readyStateSelectors.map(readyStateSelector => {
    return new Promise<void>((resolve, reject) => {
      const unsubscribe = store.subscribe(() => {
        const readyState = readyStateSelector(store.getState());
        if (readyState) {
          clearTimeout(timeoutId);
          unsubscribe();
          resolve();
        }
      });
      const timeoutId = setTimeout(() => {
        unsubscribe();
        reject(new Error(`Failed to fetch SSR data for ${component.displayName} (timeout)`));
      }, requestTimeout);
    });
  });
}

router.get('*', async (req, res) => {
  const batches: Array<MatchedRoute<{}>> = matchRoutes(routes, req.path);
  if (!batches.length) {
    res.sendStatus(404);
    return;
  }
  const urlChunks = req.originalUrl.split('?');
  const queryString = urlChunks.length > 1 ? urlChunks[1] : '';

  const store = storeFactory();
  // const locale = req.language.replace('_', '-');
  // store.dispatch(i18nActions.setLocale(locale));

  const prefetchingPromises = batches.reduce((promises, batch: MatchedRoute<{}>) =>
    promises.concat(fetchComponentData(batch, store, queryString, req.cookies))
  , []);
  try {
    await Promise.all(prefetchingPromises);
  } catch (e) {
    logger.error(e);
    res.status(500).send('Internal server error');
  }
  const context: { url?: string } = {};
  let markup = '';
  let styles = '';
  const cache = createCache({ key: 'custom' });
  const { extractCriticalToChunks, constructStyleTagsFromChunks } = createEmotionServer(cache);
  try {
    markup = renderToString(
      <CacheProvider value={cache}>
        <Provider store={store}>
          <StaticRouter
            location={req.url}
            context={context}
          >
            {renderRoutes(routes)}
          </StaticRouter>
        </Provider>
      </CacheProvider>
    );
    const chunks = extractCriticalToChunks(markup);
    styles = constructStyleTagsFromChunks(chunks);
  } catch (e) {
    logger.error('renderToString() failed', e);
  }
  /**
   * When the <Redirect> component renders on the server, it will call
   * the history object's replace method. The replacemethod sets
   * context.url to be the URL generated by the location that was
   * redirected to.
   */
  if (context.url) {
    res.redirect(302, context.url);
  } else {
    const initialState = store.getState();
    const vars = {
      initialState,
      markup,
      styleTags: styles,
      title: config.site.name,
      config: pick(config, ...config.browser.usesConfigs),
    };
    res.render('index', vars, (err, html) => {
      if (err) {
        return res.status(500).send(err);
      }
      res.send(html);
    });
  }
});
